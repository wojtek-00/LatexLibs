% filename AnfragenInSQL
% !TeX root = ../main.tex
%%%%%


\begin{table}[H]
    \scriptsize
    \centering
    \begin{minipage}[t]{0.3\textwidth}
        \centering
        \textbf{Gehenge} \\[3pt]
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Gnr} & \textbf{GName} & \textbf{Flaeche} \\
            \hline
            1 & Wald & 20 \\
            \hline
            2 & Feld & 10 \\
            \hline
            3 & Weide & 9 \\
            \hline
        \end{tabular}
    \end{minipage}
    \hspace{0.2cm}
    \begin{minipage}[t]{0.3\textwidth}
        \centering
        \textbf{Tier} \\[3pt]
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Gnr} & \textbf{TName} & \textbf{Gattung} \\
            \hline
            1 & Laber & Bär \\
            \hline
            1 & Sabber & Bär \\
            \hline
            2 & Klopfer & Hase \\
            \hline
            3 & Bunny & Hase \\
            \hline
            2 & Harald & Schaf \\
            \hline
            3 & Walter & Schaf \\
            \hline
        \end{tabular}
    \end{minipage}
    \hspace{0.2cm}
    \begin{minipage}[t]{0.3\textwidth}
        \centering
        \textbf{Art} \\[3pt]
        \begin{tabular}{|c|c|}
            \hline
            \textbf{Gattung} & \textbf{Min Fläche} \\
            \hline
            Bär & 8 \\
            \hline
            Hase & 2 \\
            \hline
            Schaf & 5 \\
            \hline
        \end{tabular}
    \end{minipage}
\end{table}


\section{Ausgabe der Informationen}

    \begin{lstlisting}[style=sqlstyle]
        SELECT Gname FROM Gehege
    \end{lstlisting}

    \paragraph{Ergebniss}

    \begin{table}[H]
        \centering
        \begin{tabular}{|c|}
            \hline
            \textbf{GName} \\
            \hline
            Wald \\
            Feld \\
            Weide \\
            \hline
        \end{tabular}
    \end{table}

    \begin{itemize}
        \item \rCode{FROM} - Tabellen mit relevanten Informationen
        \item \rCode{SELECT} - Attribute für die Ausgabe
        \item Ergebniss ist eine Tabelle, die nicht gespeichert wird
    \end{itemize}

    \pheading{Ausgabe mit Angabe der Tabelle beim Attribut}
    \begin{lstlisting}[style=sqlstyle]
        SELECT Gehege.Gname FROM Gehege
    \end{lstlisting}

    \subsection{\rCode{DISCTINCT}}

    Bei der Ausgabe aller Tiergattungen über den Befehl
    \begin{lstlisting}[style=sqlstyle]
        SELECT Tier.Gattung FROM Tier
    \end{lstlisting}

    werden alle Tierarten ausgegeben:
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|}
            \hline
            \textbf{Gattung} \\
            \hline
            Bär \\
            Bär \\
            Hase \\
            Hase \\
            Schaf \\
            Schaf \\
            \hline
        \end{tabular}
    \end{table}

    Daher muss den Befehl \rCode{DISTINCT} verwendet werden, um alles auszufiltern:
    \begin{lstlisting}[style=sqlstyle]
        SELECT DISTINCT Tier.Gattung FROM Tier
    \end{lstlisting}

    \pheading{Ergebnisstabelle:}
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|}
            \hline
            \textbf{Gattung} \\
            \hline
            Bär \\
            Hase \\
            Schaf \\
            \hline
        \end{tabular}
    \end{table}

\subsection{Ausgabe des gesamten Inhalts einer Tabelle}
    \begin{lstlisting}[style=sqlstyle]
        SELECT * FROM Gehenge
    \end{lstlisting}

    \pheading{Ergebnis:}
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Gnr} & \textbf{GName} & \textbf{Flaeche} \\
            \hline
            1 & Wald & 20 \\
            \hline
            2 & Feld & 10 \\
            \hline
            3 & Weide & 9 \\
            \hline
        \end{tabular}
    \end{table}

\subsection{Ausgabe mit mathematischen Operation}
    \begin{lstlisting}[style=sqlstyle]
        SELECT Gehege.Gname, (Gehege.Flaeche/50.0)*100.0 FROM Gehege
    \end{lstlisting}

    \pheading{Ergebnis:}
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|}
            \hline
            \textbf{GName} & \textbf{?COLUMN?} \\
            \hline
            Wald & 40 \\
            \hline
            Feld & 20 \\
            \hline
            Weide & 18 \\
            \hline
        \end{tabular}
    \end{table}

    \begin{tcolorbox}[blue, title={Hinweis}]
        übliche Operatoren möglich:  + - * /
    \end{tcolorbox}

\subsection{Konkatenation von Zeichen}
    \subsubsection{\rCode{||} - Operator}
        \begin{lstlisting}[style=sqlstyle]
            SELECT Tier.Gattung || '::' || Tier.Tname FROM Tier
        \end{lstlisting}

    \subsubsection{ \rCode{CONCAT} - Operator}
        \begin{lstlisting}[style=sqlstyle]
            SELECT CONCAT(Tier.Gattung, '::', Tier.Tname) FROM Tier
        \end{lstlisting}

    \pheading{Ergebnis:}
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|}
            \hline
            \textbf{CONCAT} \\
            \hline
            Bär::Laber \\
            Bär::Sabber \\
            Hase::Klopfer \\
            Hase::Bunny \\
            Schaf::Harald \\
            Schaf::Walter \\
            \hline
        \end{tabular}
    \end{table}

    \begin{tcolorbox}[blue, title={Hinweis}]
        Spaltenüberschrift entspricht der Berechnungsvorschrift, evtl. aber verkürzt (oder auch \rCode{?COLUMN?})
    \end{tcolorbox}

\subsection{Umbenennung von Spalten}

    Spaltenüberschriften können im Ergebnis einer \rCode{SELECT}-Abfrage umbenannt werden.
    Dies ist besonders nützlich, wenn:
    \begin{itemize}
        \item die Spaltennamen zu technisch oder zu lang sind,
        \item Berechnungsausdrücke im Ergebnis erscheinen,
        \item mehrere Tabellen ähnliche Spaltennamen enthalten.
    \end{itemize}
    Die Umbenennung erfolgt durch die Vergabe eines \emph{Aliasnamens} für eine Spalte.
    Dabei gibt es zwei Varianten:
    \begin{enumerate}
        \item \textbf{Kurzform (oft in älteren Systemen):}
        \begin{lstlisting}[style=sqlstyle]
    SELECT Gehege.Gname Gatter
    FROM Gehege;
        \end{lstlisting}
        \item \textbf{SQL-Standard (empfohlen):}
        \begin{lstlisting}[style=sqlstyle]
    SELECT Gehege.Gname AS Gatter
    FROM Gehege;
        \end{lstlisting}
    \end{enumerate}
    Beide Varianten führen zum gleichen Ergebnis.


    \begin{tcolorbox}[gray={Beispiel mit Berechnung}]
        Auch berechnete Spalten können mit einem Alias versehen werden:
        \begin{lstlisting}[style=sqlstyle]
            SELECT Gehege.Gname AS Gatter,
                Gehege.Flaeche * 10000 AS Quadratzentimeter
            FROM Gehege;
        \end{lstlisting}

        \textbf{Ergebnis:}
            \begin{center}
                \begin{tabular}{|c|c|}
                \hline
                \textbf{GATTER} & \textbf{QUADRATZENTIMETER} \\
                \hline
                Wald & 200000 \\
                \hline
                Feld & 100000 \\
                \hline
                Weide & 90000 \\
                \hline
            \end{tabular}
        \end{center}
    \end{tcolorbox}

    \begin{tcolorbox}[gray={Beispiel mit festen Werten}]
        Neue Spalten können auch mit festen Werten erzeugt werden:
        \begin{lstlisting}[style=sqlstyle]
            SELECT 'Unser Zoo' AS Zooname,
                Tier.Tname AS Tiername,
                2005 AS Einzug,
                42 AS Beispielwert
            FROM Tier;
        \end{lstlisting}

        \textbf{Ergebnis:}
        \begin{center}
            \begin{tabular}{|c|c|c|c|}
                \hline
                \textbf{ZOONAME} & \textbf{TIERNAME} & \textbf{EINZUG} & \textbf{BEISPIELWERT} \\
                \hline
                Unser Zoo & Klopfer & 2005 & 42 \\
                \hline
                Unser Zoo & Bunny & 2005 & 42 \\
                \hline
            \end{tabular}
        \end{center}
    \end{tcolorbox}

\subsection{Reihenfolde bei der Ausgabe}
    Reihenfolge der Daten bei der Ausgabe muss nicht der Reihenfolge beim Eintragen entsprechen. Ausgabereihenfolge kann über \rCode{ORDER} BY gesteuert werden
    \begin{itemize}
        \item \rCode{ASC} ergibt aufsteigende (Default)
        \item \rCode{DESC}  ergibt absteigende Sortierung
    \end{itemize}

    \subsubsection{Ausgabe der Gehege nach aufsteigender Größe}
    \begin{lstlisting}[style=sqlstyle]
    SELECT Gehege.Gname, Gehege.Flaeche
        FROM Gehege
        ORDER BY Gehege.Flaeche ASC
    \end{lstlisting}

    \subsubsection{Ausgabe der Gattungen absteigend nach Flächenbedarf}
    \begin{sql}
        SELECT Art.Gattung, Art.MinFlaeche
            FROM Art
            ORDER BY Art.MinFlaeche DESC
    \end{sql}

    \begin{tcolorbox}[blue={Sortierung nach zwei Kriterien}]
    Eine Ergebnistabelle kann nach mehreren Spalten sortiert werden. 
    Dabei wird zunächst nach der ersten Spalte sortiert, und innerhalb gleicher Werte nach der zweiten Spalte.

    \begin{sql}
    SELECT * 
        FROM Tier
        ORDER BY Tier.Gattung DESC, Tier.Tname ASC;
    \end{sql}

    In diesem Beispiel erfolgt die Sortierung \textbf{absteigend} nach \rCode{Gattung} 
    und \textbf{aufsteigend} nach \rCode{Tname}.
    \end{tcolorbox}

\section{Auswahlkriterien mit \rCode{WHERE}}

Mit der \rCode{WHERE}-Klausel können gezielt nur jene Datensätze ausgewählt werden, 
die bestimmte Bedingungen erfüllen. Ohne \rCode{WHERE} werden alle Zeilen ausgegeben.

\paragraph{Beispiel 1:} Alle Tiere der Gattung Schaf
    \begin{sql}
    SELECT Tier.Tname
        FROM Tier
        WHERE Tier.Gattung = 'Schaf';
    \end{sql}

\paragraph{Beispiel 2:} Gattungen mit einer Mindestfläche von mindestens 4, 
die jedoch keine Bären sind
    \begin{sql}
    SELECT Art.Gattung
        FROM Art
        WHERE Art.MinFlaeche >= 4 AND Art.Gattung <> 'Baer';
    \end{sql}

    \begin{tcolorbox}[blue={Hinweis}]
        \begin{itemize}
            \item Mehrere Bedingungen können mit \rCode{AND}, \rCode{OR} und \rCode{NOT} kombiniert werden.
            \item Für Textvergleiche wird häufig das Schlüsselwort \rCode{LIKE} verwendet.
        \end{itemize}
    \end{tcolorbox}

\subsection{Mustervergleich mit \rCode{LIKE}:}
    \begin{itemize}
        \item \rCode{\%} steht für beliebig viele Zeichen.
        \item \rCode{\_} steht für genau ein Zeichen.
    \end{itemize}

    \paragraph{Beispiel 1:} Ausgabe aller Tiernamen, die mit 's' beginnen
    \begin{sql}
    SELECT * 
        FROM Tier
        WHERE Tname LIKE 'S%';
    \end{sql}

    Dies gibt alle Tiere aus, deren Name mit \rCode{S} beginnt (z.\,B.\ Sabber oder Susi).

    \paragraph{Beispiel 2:} Ausgabe aller Tiernamen, die ein 'a' enthalten
    \begin{sql}
        SELECT Tier.Tname
            FROM Tier
            WHERE Tier.Tname LIKE '%a%'
    \end{sql}

    \paragraph{Beispiel 3:} Ausgabe aller Tiernamen, deren dritter Buchstabe ein 'n' ist
    \begin{sql}
        SELECT Tier.Tname
            FROM Tier
            WHERE Tier.Tname LIKE '__n%'
    \end{sql}

    \paragraph{Beispiel 4:} Ausgabe aller Tiernamen, die ein \% enthalten
    \begin{sql}
        SELECT Tier.Tname
            FROM Tier
            WHERE Tier.Tname LIKE '%/%%' ESCAPE '/'
    \end{sql}

    \begin{tcolorbox}[blue={Hinweis}]
        Folgenze Zeilen sind ävuivalent
        \begin{sql}
            Art.Gattung<>'Baer'
            Art.Gattung NOT LIKE 'Baer'
            NOT (Art.Gattung LIKE 'Baer')
        \end{sql}
        Verwendung erster Variante bevorzugt, um kenntlich zu machen, dass hier ein exakter Textvergleich erfolgt
    \end{tcolorbox}

\subsection{Umwandlung von Texten mit \rCode{LOWER} und \rCode{UPPER}}

Mit den Funktionen \rCode{LOWER()} und \rCode{UPPER()} können Textwerte in Klein- bzw. Großbuchstaben umgewandelt werden. 
Dies ist besonders nützlich bei Vergleichen, da SQL-Systeme oft zwischen Groß- und Kleinschreibung unterscheiden.

\textbf{Beispiel 1:} Ausgabe aller Tiere der Gattung \textbf{Schaf}, unabhängig von der Schreibweise
    \begin{sql}
        SELECT LOWER(Tier.Tname)
            FROM Tier
            WHERE LOWER(Tier.Gattung) = 'schaf';
    \end{sql}

\textbf{Beispiel 2:} Ausgabe der Tiernamen in Großbuchstaben
    \begin{sql}
    SELECT UPPER(Tier.Tname) AS Gross
        FROM Tier;
    \end{sql}

\begin{tcolorbox}[blue={Hinweis}]
    \begin{itemize}
        \item \rCode{LOWER()} – wandelt alle Buchstaben in Kleinbuchstaben.
        \item \rCode{UPPER()} – wandelt alle Buchstaben in Großbuchstaben.
    \end{itemize}
\end{tcolorbox}

\subsection{Auswertung einer SQL-Anfrage und Umgang mit \rCode{NULL}}
\begin{tcolorbox}[gray={Auswertung von Bedingungen in SQL}]
    Bei der Auswertung einer SQL-Anfrage werden nur jene Zeilen in das Ergebnis aufgenommen,
    für die die \rCode{WHERE}-Bedingung den Wert \rCode{TRUE} liefert.  
    Zeilen mit dem Ergebnis \rCode{FALSE} oder \rCode{UNKNOWN} (z.\,B.\ durch \rCode{NULL}) 
    werden nicht berücksichtigt.

    \textbf{Beispiel: Erstellung und Befüllung einer Tabelle}
    \begin{sql}
    CREATE TABLE Person(
        Pnr INTEGER,
        Name VARCHAR(5),
        Gehalt INTEGER,
        PRIMARY KEY (Pnr)
    );

    INSERT INTO Person VALUES (1, 'Eddy', 2500);
    INSERT INTO Person VALUES (2, 'Egon', NULL);
    INSERT INTO Person VALUES (3, 'Erna', 1700);
    \end{sql}

    \textbf{Beispiel 1:} Personen mit einem Gehalt unter 2000
    \begin{sql}
    SELECT Person.Name
        FROM Person
        WHERE Person.Gehalt < 2000;
    \end{sql}

    \textbf{Ergebnis:}
    \begin{center}
        \begin{tabular}{|c|}
            \hline
            \textbf{NAME} \\
            \hline
            Erna \\
            \hline
        \end{tabular}
    \end{center}

    \textbf{Beispiel 2:} Einbeziehen von Personen ohne Gehaltsangabe
    \begin{sql}
    SELECT Person.Name
        FROM Person
        WHERE Person.Gehalt < 2000 OR Person.Gehalt IS NULL;
    \end{sql}

    \textbf{Ergebnis:}
    \begin{center}
        \begin{tabular}{|c|}
            \hline
            \textbf{NAME} \\
            \hline
            Egon \\
            Erna \\
            \hline
        \end{tabular}
    \end{center}

    \textbf{Wichtig:}  
    Vergleiche mit \rCode{NULL} liefern nie \rCode{TRUE}, sondern \rCode{UNKNOWN}.  
    Daher müssen Prüfungen auf fehlende Werte immer mit \rCode{IS NULL} oder \rCode{IS NOT NULL} erfolgen.
\end{tcolorbox}

\subsection{Nutzung von Aggregatsfunktionen}

    SQL stellt verschiedene Funktionen für einfache statistische Auswertungen bereit.  
    Aggregatsfunktionen fassen mehrere Zeilen zu einem einzigen Ergebniswert zusammen.

    \textbf{Wichtige Aggregatsfunktionen:}
    \begin{itemize}
        \item \rCode{MAX()} – größter Wert einer Spalte
        \item \rCode{MIN()} – kleinster Wert einer Spalte
        \item \rCode{SUM()} – Summe aller Werte
        \item \rCode{AVG()} – Durchschnittswert
        \item \rCode{COUNT()} – Anzahl der Zeilen
    \end{itemize}

    \textbf{Beispiele:}
    \begin{sql}
    -- find the largest enclosure area
    SELECT MAX(Gehege.Flaeche)
    FROM Gehege;

    -- find the smallest enclosure area with a custom column name
    SELECT MIN(Gehege.Flaeche) AS KleinsteFlaeche
    FROM Gehege;

    -- calculate the total area of all enclosures
    SELECT SUM(Gehege.Flaeche) AS Gesamtflaeche
    FROM Gehege;

    -- count the total number of animals
    SELECT COUNT(*) AS Tieranzahl
    FROM Tier;
    \end{sql}

    \begin{tcolorbox}[blue={Hinweis zu \rCode{COUNT}}]
        \begin{itemize}
            \item \rCode{COUNT(*)} zählt alle Zeilen, auch wenn einzelne Werte \rCode{NULL} sind.
            \item \rCode{COUNT(Attribut)} zählt nur Zeilen, in denen das Attribut \textbf{nicht NULL} ist.
        \end{itemize}
    \end{tcolorbox}

    \textbf{Beispiel:} Äquivalente Zählung über ein bestimmtes Attribut
    \begin{sql}
    -- count all non-null values in the column "Gattung"
    SELECT COUNT(Tier.Gattung) AS Tieranzahl
    FROM Tier;
    \end{sql}


\subsection{Anfragen über mehrere Tabellen}

    Bisherige SQL-Anfragen bezogen sich nur auf eine einzelne Tabelle.  
    In realistischen Szenarien sind Informationen jedoch oft auf mehrere Tabellen verteilt.  
    Um Daten aus diesen Tabellen gemeinsam auszuwerten, werden Verknüpfungen (Joins) verwendet.  
    Dabei entsteht zunächst das Kreuzprodukt aller beteiligten Tabellen, das anschließend über Bedingungen
    eingeschränkt wird.

    \textbf{Beispiel:} Ausgabe aller Tiere mit dem Namen ihres Geheges
    \begin{sql}
    -- select animal names with their corresponding enclosure names
    SELECT Tier.Tname, Gehege.Gname
        FROM Tier, Gehege
        WHERE Tier.GNr = Gehege.GNr;
    \end{sql}

    \textbf{Erläuterung:}
    \begin{itemize}
        \item Die \rCode{FROM}-Zeile enthält alle Tabellen, die für die Anfrage benötigt werden.
        \item Zunächst wird das Kreuzprodukt (\textit{Cartesian Product}) der Tabellen gebildet.
        \item Über die \rCode{WHERE}-Bedingung wird dieses Ergebnis auf passende Kombinationen reduziert,
            z.\,B.\ entsprechend der Fremdschlüsselbeziehung.
    \end{itemize}

    \textbf{Beispiel für das Kreuzprodukt:}
    \begin{sql}
    -- create the full Cartesian product of both tables
    SELECT *
        FROM Tier, Gehege;
    \end{sql}

    \begin{tcolorbox}[gray={Hinweis zum Kreuzprodukt}]
    Das Kreuzprodukt enthält alle möglichen Kombinationen der Zeilen aus beiden Tabellen
    und führt häufig zu inhaltlich unsinnigen Ergebnissen.  
    Daher ist es notwendig, die Beziehung zwischen den Tabellen mit einer \rCode{WHERE}-Bedingung
    einzuschränken.
    \end{tcolorbox}

    \textbf{Korrigierte Anfrage:}
    \begin{sql}
    -- select only matching rows based on the foreign key relationship
    SELECT *
        FROM Tier, Gehege
        WHERE Tier.GNr = Gehege.GNr;
    \end{sql}

\begin{tcolorbox}[red = {Hinweis}]
    Ein Kreuzprodukt mit einer Tabelle, die keine Einträge enthält, führt zu einer Ausgabe ohne Elemente. Das Kreuzprodukt verknüpft nämlich alle Einträge der ersten Tabelle mit allen Einträgen der zweiten Tabelle. Wenn eine der Tabellen leer ist, können folglich keine Kombinationen gebildet werden.
\end{tcolorbox}

\subsection{Łączenie tabel za pomocą \rCode{JOIN}}

SQL umożliwia łączenie danych z wielu tabel poprzez operator \rCode{JOIN}.  
W przeciwieństwie do starszej składni, w której tabele były wymieniane po prostu w klauzuli \rCode{FROM},  
podejście z użyciem \rCode{JOIN} jest bardziej czytelne i ułatwia zrozumienie relacji między tabelami.

\pheading{Podstawowe rodzaje JOIN:}
\begin{itemize}
    \item \rCode{INNER JOIN} – zwraca tylko te wiersze, które mają dopasowanie w obu tabelach.
    \item \rCode{LEFT JOIN} – zwraca wszystkie wiersze z tabeli po lewej stronie, nawet jeśli brak dopasowania w prawej.
    \item \rCode{RIGHT JOIN} – zwraca wszystkie wiersze z tabeli po prawej stronie, nawet jeśli brak dopasowania w lewej.
    \item \rCode{FULL JOIN} – zwraca wszystkie wiersze z obu tabel (jeśli obsługiwane przez DBMS).
\end{itemize}

\begin{tcolorbox}[blue={Wskazówka dotycząca JOIN}]
\begin{itemize}
    \item Warunek po słowie kluczowym \rCode{ON} określa relację między tabelami — zwykle poprzez klucz główny i klucz obcy.
    \item \rCode{INNER JOIN} działa tak samo jak starsza metoda z wieloma tabelami i warunkiem \rCode{WHERE}.
    \item W przypadku \rCode{LEFT JOIN} lub \rCode{RIGHT JOIN} brakujące wartości zostaną zastąpione przez \rCode{NULL}.
\end{itemize}
\end{tcolorbox}

\subsubsection{Porównanie \rCode{INNER}, \rCode{LEFT} i \rCode{RIGHT JOIN}}

Aby zrozumieć różnicę między poszczególnymi typami \rCode{JOIN}, rozważmy prosty przykład z dwiema tabelami.  
Tabela \rCode{Student} zawiera listę studentów, a tabela \rCode{Kurs} — listę kursów, do których zapisano wybranych studentów.

\begin{table}[H]
    \centering
    \textbf{Tabele źródłowe} \\ [10pt]
    \begin{minipage}[t]{0.4\textwidth}
        \centering
        \textbf{Student} \\[3pt]
        \begin{tabular}{|c|c|}
            \hline
            \textbf{ID} & \textbf{Name} \\
            \hline
            1 & Anna \\
            2 & Ben \\
            3 & Clara \\
            4 & David \\ % bez kursu
            \hline
        \end{tabular}
    \end{minipage}
    \hspace{0.3cm}
    \begin{minipage}[t]{0.4\textwidth}
        \centering
        \textbf{Kurs} \\ [3pt]
        \begin{tabular}{|c|c|}
            \hline
            \textbf{KursID} & \textbf{StudentID} \\
            \hline
            1 & 1 \\
            2 & 1 \\
            3 & 2 \\
            4 & 5 \\ % student nie istnieje
            \hline
        \end{tabular}
    \end{minipage}
\end{table}

\pheading{1. \rCode{INNER JOIN} – tylko dopasowane rekordy}
\begin{sql}
-- show only students who are registered in a course
SELECT Student.Name, Kurs.KursID
    FROM Student
    INNER JOIN Kurs ON Student.ID = Kurs.StudentID;
\end{sql}

\pheading{Wynik:}
\begin{center}
\begin{tabular}{|c|c|}
    \hline
    \textbf{Name} & \textbf{KursID} \\
    \hline
    Anna  & 1 \\
    Anna  & 2 \\
    Ben   & 3 \\
    \hline
\end{tabular}
\end{center}

\pheading{2. \rCode{LEFT JOIN} – wszystkie rekordy z lewej tabeli}
\begin{sql}
-- show all students, even if they are not registered in any course
SELECT Student.Name, Kurs.KursID
    FROM Student
    LEFT JOIN Kurs ON Student.ID = Kurs.StudentID;
\end{sql}

\textbf{Wynik:}
\begin{center}
\begin{tabular}{|c|c|}
    \hline
    \textbf{Name} & \textbf{KursID} \\
    \hline
    Anna  & 1 \\
    Anna  & 2 \\
    Ben   & 3 \\
    Clara & NULL \\
    David & NULL \\
    \hline
\end{tabular}
\end{center}

\pheading{3. \rCode{RIGHT JOIN} – wszystkie rekordy z prawej tabeli}
\begin{sql}
-- show all courses, even if no student is assigned
SELECT Student.Name, Kurs.KursID
    FROM Student
    RIGHT JOIN Kurs ON Student.ID = Kurs.StudentID;
\end{sql}

\textbf{Wynik:}
\begin{center}
\begin{tabular}{|c|c|}
    \hline
    \textbf{Name} & \textbf{KursID} \\
    \hline
    Anna & 1 \\
    Anna & 2 \\
    Ben  & 3 \\
    NULL & 4 \\ % kurs bez studenta
    \hline
\end{tabular}
\end{center}

\begin{tcolorbox}[gray={Opis}]
\begin{itemize}
    \item \rCode{INNER JOIN} – pokazuje tylko wiersze z dopasowaniem po obu stronach.
    \item \rCode{LEFT JOIN} – zwraca wszystkie wiersze z tabeli po lewej stronie od \rCode{JOIN}, nawet jeśli nie mają dopasowania w tabeli po prawej.
    \item \rCode{RIGHT JOIN} – zwraca wszystkie wiersze z tabeli po prawej stronie od \rCode{JOIN}, nawet jeśli nie mają dopasowania w tabeli po lewej.
\end{itemize}
\end{tcolorbox}

\textbf{Różnica w praktyce:}
\begin{itemize}
    \item W zapytaniu \rCode{LEFT JOIN} – lewa tabela (\textbf{Student}) to ta po słowie \rCode{FROM}. Wszystkie jej rekordy są zachowane.
    \item W zapytaniu \rCode{RIGHT JOIN} – prawa tabela (\textbf{Kurs}) to ta po \rCode{JOIN}. Wszystkie jej rekordy są zachowane.
\end{itemize}
