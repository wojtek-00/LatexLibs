% filename TabellenInSQL.tex
% !TeX root = ../main.tex
%%%%%

\section{Tabellendefinition in SQL}

\begin{table}[H]
    \centering
    \begin{minipage}{0.4\textwidth}
        \centering
        \textbf{Verkäufer} \\[3pt]
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Vnr} & \textbf{Name} & \textbf{Status} & \textbf{Gehalt} \\
            \hline
            1001 & Udo & Junior & 1500 \\
            \hline
            1002 & Ute & Senior & 1900 \\
            \hline
            1003 & Uwe & Senior & 2000 \\
            \hline
        \end{tabular}
    \end{minipage}
    \hspace{0.9cm}
    \begin{minipage}{0.4\textwidth}
        \centering
        \textbf{Kunde} \\[3pt]
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Knr} & \textbf{Name} & \textbf{Betreuer} \\
            \hline
            1 & Egon & 1001 \\
            \hline
            2 & Erwin & 1001 \\
            \hline
            3 & Erna & 1002 \\
            \hline
        \end{tabular}
    \end{minipage}
\end{table}

\textbf{Hinweis:} Durch eine Fremdschlüsselbeziehung (Kunde.Betreuer → Verkaeufer.Vnr) wird festgelegt, dass jeder Kunde einen existierenden Verkäufer als Betreuer haben muss.

\begin{lstlisting}[style=sqlstyle, caption={Tabellendefinition in SQL}]
CREATE TABLE Verkaeufer(
    Vnr INTEGER,
    Name VARCHAR(6),
    Status VARCHAR(7),
    Gehalt INTEGER,
    PRIMARY KEY (Vnr)
);
CREATE TABLE Kunde(
    Knr INTEGER,
    Name Varchar(6),
    Betreuer INTEGER,
    PRIMARY KEY (Knr),
    CONSTRAINT FK_Kunde
        FOREIGN KEY (Betreuer)
        REFERENCES Verkaeufer(Vnr)
)
\end{lstlisting}

\begin{itemize}
    \item Eigenschaften (z.B. Attribute) werden durch Kommata getrennt
    \item Zeilenumbrüche zur Übersichtlichkeit, aber nicht zwingend erforderlich
    \item Trennung von  mehreren Befehlen üblicherweise durch Semikolon
\end{itemize}

\subsection{Primärschlussel}
Klucz główny (Primärschlüssel) to mechanizm, który zapewnia, że każdy wiersz w tabeli jest unikalny i da się go jednoznacznie zidentyfikować. Ale oprócz „weryfikacji różności” ma też kilka dodatkowych, bardzo ważnych funkcji.
\begin{itemize}
    \item Kady wpis w tej kolumnie musi być unikalny - numery nie mogą się powtarzać
    \item Blokuje wartości NULL - Kolumna będąca kluczem głównym musi zawsze zawierać jakąś wartość — nie może być pusta (NULL).
    \item Umożliwia tworzenie relacji z innymi tabelami - Klucz główny jest punktem odniesienia dla kluczy obcych (Foreign Keys).
\end{itemize}

\pheading{Beispiel}
Linia:
\begin{lstlisting}[style=sqlstyle]
    PRIMARY KEY (Vnr)
\end{lstlisting}
oznacza, że kolumna \textbf{Vnr} to klucz główny (Primärschlüssel).

\subsection{Constraint}
Constraint (ograniczenie) to reguła określająca zasady, jakie wartości mogą występować w kolumnach tabeli. 
\textbf{Baza danych automatycznie sprawdza ich poprawność przy dodawaniu, usuwaniu lub modyfikowaniu danych.} 
Dzięki ograniczeniom możliwe jest zapewnienie integralności i spójności danych pomiędzy tabelami.

\begin{itemize}
    \item Ograniczenia mogą dotyczyć pojedynczej kolumny lub relacji między tabelami.
    \item Każde ograniczenie może posiadać nazwę — ułatwia to późniejsze modyfikacje lub usunięcie.
    \item Do najczęściej używanych ograniczeń należą:
    \begin{itemize}
        \item \texttt{PRIMARY KEY} – gwarantuje unikalność i brak wartości \texttt{NULL}.
        \item \texttt{FOREIGN KEY} – definiuje relację między tabelami (klucz obcy) - To kolumna w jednej tabeli, która odwołuje się do klucza głównego w innej tabeli.
        \item \texttt{REFERENCES} – wskazuje, do której tabeli i kolumny odnosi się klucz obcy.
    \end{itemize}
\end{itemize}

\pheading{Beispiel}
\begin{lstlisting}[style=sqlstyle]
CREATE TABLE Kunde(
    Knr INTEGER,
    Name VARCHAR(6),
    Betreuer INTEGER,
    PRIMARY KEY (Knr),
    CONSTRAINT FK_Kunde
        FOREIGN KEY (Betreuer)
        REFERENCES Verkaeufer(Vnr)
);
\end{lstlisting}

Powyższy przykład definiuje ograniczenie o nazwie \textbf{FK\_Kunde}, 
które ustala relację pomiędzy kolumną \textbf{Betreuer} w tabeli \textbf{Kunde} 
a kolumną \textbf{Vnr} w tabeli \textbf{Verkaeufer}. 
Dzięki temu baza danych zapewnia, że każda wartość w kolumnie \textbf{Betreuer} 
odpowiada istniejącemu sprzedawcy w tabeli \textbf{Verkaeufer}.

\begin{tcolorbox}[blue, title={Hinweis}]
    \texttt{CONSTRAINT} definiert eine benannte Regel (Einschränkung), 
    die von der Datenbank automatisch überprüft wird.  
    \texttt{FOREIGN KEY} gibt die Spalte in der aktuellen Tabelle an, 
    während \texttt{REFERENCES} bestimmt, auf welche Tabelle und Spalte 
    sich diese Spalte bezieht.  

    Bei jedem Einfügen eines neuen Datensatzes in die Tabelle \texttt{Kunde} 
    überprüft das Datenbanksystem automatisch, ob der in der Spalte 
    \texttt{Betreuer} eingetragene Wert in \texttt{Verkaeufer.Vnr} existiert.  
    Ist dies der Fall, wird der Datensatz gespeichert,  
    andernfalls wird der Vorgang abgelehnt.
\end{tcolorbox}


\begin{tcolorbox}[red, title={Hinweis}]
    \texttt{FOREIGN KEY} zawsze musi odnosić się do \texttt{PRIMARY KEY} (lub innego klucza unikalnego) w innej tabeli.
\end{tcolorbox}

Więcej do tego tematu w punkcie \autoref{sql:constraints}

\section{Einfügen, Löschen und Ändern von Daten}
\subsection{Einfügen}
\begin{lstlisting}[style=sqlstyle]
INSERT INTO Verkaeufer VALUES(1001,'Udo','Junior',1500);
INSERT INTO Verkaeufer VALUES(1002,'Ute','Senior',1900);
INSERT INTO Verkaeufer VALUES(1003,'Uwe','Senior',2000)
\end{lstlisting}

Eingabe der Werte muss der Reihenfolge der Attribute in der Tabelle entsprechen. Es muss für jede Spalte ein Wert angegeben werden

\subsubsection{Einfügen mit Angabe der Spalten}
Es können auch eingtäge in explicite Spalten gemacht werden. Dann müssen wir erstmal die Spalten nennen und dann entsprechend Values übergeben
\begin{lstlisting}[style=sqlstyle]
INSERT INTO Verkaeufer(Vnr,Name,Status) VALUES(1004,'Ulf','Junior');
INSERT INTO Verkaeufer(Vnr,Gehalt,Name) VALUES(1005,1300,'Urs')
\end{lstlisting}

\subsubsection{weitere Beispiele}

\pheading{Einfügen mit Nullwerten}
\begin{lstlisting}[style=sqlstyle]
INSERT INTO Kunde VALUES(4,'Edna',NULL);
\end{lstlisting}

\subsection{Update}
Dieser Befehl ändert die Werte eines bestehenden Datensatzes in der Tabelle \texttt{Kunde}.  
Mit \texttt{SET} werden die neuen Werte für die angegebenen Spalten festgelegt,  
und die \texttt{WHERE}-Bedingung bestimmt, welcher Datensatz aktualisiert wird.  
Alle definierten \texttt{CONSTRAINTS} (z.\,B. \texttt{FOREIGN KEY}) müssen dabei erfüllt bleiben – 
das bedeutet, dass der neue Wert in \texttt{Betreuer} nur gesetzt werden kann, 
wenn dieser auch in \texttt{Verkaeufer.Vnr} existiert.

    \begin{lstlisting}[style=sqlstyle]
    UPDATE Kunde
        SET Name='Edwina', Betreuer=1002
        WHERE Name='Edna'
    \end{lstlisting}
Der Befehl sucht alle Datensätze in der Tabelle \texttt{Kunde}, bei denen der Name \texttt{'Edna'} ist, 
und ändert diesen Namen zu \texttt{'Edwina'} sowie den Betreuer auf \texttt{1002}. 
Vor dem Speichern prüft die Datenbank alle \texttt{CONSTRAINTS} – 
die neue Betreuer-Nummer muss daher bereits in \texttt{Verkaeufer.Vnr} existieren, 
ansonsten wird die Aktualisierung verweigert.

\pheading{Weiterer Beispiel}
    \begin{lstlisting}[style=sqlstyle]
        UPDATE Verkaeufer SET Gehalt=Gehalt * 1.05
    \end{lstlisting}


\subsection{Überprüfung des Inhalts einer Tabelle}
    Dieser Befehl zeigt alle gespeicherten Datensätze einer Tabelle an.  
    Das Sternchen \texttt{*} steht dabei für „alle Spalten“.  
    So können sämtliche Inhalte der angegebenen Tabelle überprüft werden, 
    z.\,B. um zu kontrollieren, ob Einträge korrekt eingefügt oder aktualisiert wurden.

    \begin{lstlisting}[style=sqlstyle]
        SELECT * FROM <Tabellenname>
    \end{lstlisting}



\subsection{Delete}
    \begin{lstlisting}[style=sqlstyle]
DELETE FROM <Tabellenname> WHERE <Bedingung>
    \end{lstlisting}

    Mit dem \texttt{DELETE}-Befehl können Datensätze aus einer Tabelle gelöscht werden, 
    die eine bestimmte Bedingung erfüllen. Wird keine Bedingung angegeben, 
    löscht der Befehl \texttt{DELETE} alle Datensätze der Tabelle.

\pheading{Beispiel}
    \begin{lstlisting}[style=sqlstyle]
        DELETE FROM Kunde WHERE Knr = 3;
    \end{lstlisting}
    In diesem Beispiel wird der Datensatz mit der Kundennummer \texttt{3} aus der Tabelle \texttt{Kunde} entfernt.

\subsubsection{Delete on Cascade}
    Die Anweisung \texttt{ON DELETE CASCADE} definiert das Verhalten der Datenbank beim Löschen von Datensätzen in einer übergeordneten Tabelle.
    Sie legt fest, dass alle abhängigen Datensätze in der untergeordneten Tabelle automatisch gelöscht werden, 
    sobald der zugehörige Datensatz in der übergeordneten Tabelle entfernt wird.

    Im folgenden Beispiel bezieht sich die Tabelle \texttt{Kunde} über den Fremdschlüssel \texttt{Betreuer} auf die Tabelle \texttt{Verkaeufer}.
    Wird ein Verkäufer gelöscht, so werden alle Kunden, die diesem Verkäufer zugeordnet sind, automatisch mit gelöscht.

    \begin{lstlisting}[style=sqlstyle]
    CREATE TABLE Verkaeufer (
        Vnr INTEGER PRIMARY KEY,
        Name VARCHAR(20)
    );

    CREATE TABLE Kunde (
        Knr INTEGER PRIMARY KEY,
        Name VARCHAR(20),
        Betreuer INTEGER,
        CONSTRAINT FK_Kunde
            FOREIGN KEY (Betreuer)
            REFERENCES Verkaeufer(Vnr)
            ON DELETE CASCADE
    );
    \end{lstlisting}

    \subsubsection{Verhalten beim Löschen abhängiger Datensätze}

Der SQL-Standard definiert mehrere Möglichkeiten, wie eine Datenbank mit 
abhängigen Datensätzen umgeht, wenn ein referenzierter Eintrag aus der übergeordneten Tabelle gelöscht wird. 
Diese Optionen werden in der \texttt{FOREIGN KEY}-Definition mit der Klausel \texttt{ON DELETE} angegeben:

\begin{itemize}
    \item \textbf{NO ACTION} — Standardverhalten. 
    Das Löschen eines übergeordneten Datensatzes ist nicht erlaubt, 
    solange abhängige Datensätze in der untergeordneten Tabelle existieren. (NO ACTION nie pozwala usunąć rekordu z tabeli nadrzędnej, jeśli w tabeli podrzędnej istnieją powiązane dane.)
    
    \item \textbf{CASCADE} — Entspricht der vorgestellten „Löschfortpflanzung“. 
    Wird ein Datensatz in der übergeordneten Tabelle gelöscht, 
    werden alle zugehörigen abhängigen Datensätze automatisch mit entfernt.
    
    \item \textbf{SET NULL} — Beim Löschen eines referenzierten Datensatzes 
    wird der Fremdschlüsselwert in allen abhängigen Datensätzen automatisch auf \texttt{NULL} gesetzt.
    
    \item \textbf{SET DEFAULT} — Wenn für den Fremdschlüssel ein Standardwert (\texttt{DEFAULT}) definiert ist, 
    wird dieser Wert in den abhängigen Datensätzen gesetzt, 
    sobald der referenzierte Datensatz gelöscht wird.

    \begin{lstlisting}[style=sqlstyle]
        CREATE TABLE Kunde (
            Knr INTEGER PRIMARY KEY,
            Name VARCHAR(20),
            Betreuer INTEGER DEFAULT 1000,
            CONSTRAINT FK_Kunde
                FOREIGN KEY (Betreuer)
                REFERENCES Verkaeufer(Vnr)
                ON DELETE SET DEFAULT
        );
    \end{lstlisting}
        Tutaj Każdy klient (Kunde) ma przypisanego opiekuna (Betreuer), Jeśli ten opiekun zostanie usunięty, to kolumna Betreuer klienta zostanie automatycznie ustawiona na wartość domyślną (1000).
    \end{itemize}
\subsubsection{Löschen von Tabellen}

Das Löschen ganzer Tabellen kann bei bestehenden Fremdschlüsselbeziehungen zu Problemen führen. 
Je nach gewählter Option wird das Verhalten des Befehls \texttt{DROP TABLE} vom Datenbankmanagementsystem (DBMS) unterschiedlich gehandhabt.

\pheading{Beispielvarianten}

\begin{itemize}
    \item \textbf{DROP TABLE <Tabellenname> RESTRICT}\\
    Löscht die Tabelle nur, wenn keine abhängigen Tabellen existieren. 
    Dadurch wird verhindert, dass Fremdschlüsselbeziehungen ins Leere zeigen.
    
    \item \textbf{DROP TABLE <Tabellenname> CASCADE}\\
    Löscht die angegebene Tabelle und entfernt in abhängigen Tabellen die entsprechenden Fremdschlüsselbeziehungen. 
    Die eigentlichen Daten in diesen abhängigen Tabellen bleiben jedoch bestehen.
    
    \item \textbf{Kurzform: DROP TABLE <Tabellenname>}\\
    Führt – abhängig vom verwendeten DBMS – automatisch entweder die \texttt{RESTRICT}- oder \texttt{CASCADE}-Variante aus.
\end{itemize}

\begin{tcolorbox}[red, title={Hinweis}]
    Das vorschnelle Löschen von Tabellen sollte vermieden werden, insbesondere in produktiven Datenbanken. 
    Fremdschlüsselabhängigkeiten sollten zuvor sorgfältig geprüft werden, um Dateninkonsistenzen zu verhindern.
\end{tcolorbox}


\section{Datentypen in SQL}

Obwohl ein allgemeiner SQL-Standard existiert, unterscheiden sich die Datentypen zwischen verschiedenen Datenbankmanagementsystemen (DBMS) erheblich. 
Die folgenden Ausführungen beziehen sich auf PostgreSQL und beschränken sich auf die wichtigsten Datentypen.

\subsection{Ganze Zahlen}
\begin{itemize}
    \item \textbf{\rCode{SMALLINT}}: Wertebereich von \texttt{-32.768} bis \texttt{+32.767}
    \item \textbf{\rCode{INTEGER}}: Wertebereich von \texttt{-2.147.483.647} bis \texttt{+2.147.483.646}
    \item \textbf{\rCode{BIGINT}}: für sehr große Ganzzahlen (bis ca. $\pm 9{,}22 \times 10^{18}$)
\end{itemize}

\subsection{Kommazahlen}
    \begin{itemize}
        \item \textbf{\rCode{DECIMAL(p, q)}} oder \textbf{\rCode{NUMERIC(p, q)}}: 
        ermöglicht die Angabe von Genauigkeit \texttt{p} (Gesamtzahl der Stellen) 
        und \texttt{q} (Nachkommastellen); 
        bis zu 131.072 Stellen vor und 16.383 Stellen nach dem Komma.
        \item \textbf{\rCode{REAL}}: Gleitkommazahlen mit mindestens sechs signifikanten Stellen 
        (häufig auch als \rCode{FLOAT} bezeichnet).
        \item \textbf{\rCode{DOUBLE PRECISION}}: Gleitkommazahlen mit mindestens 15 signifikanten Stellen 
        (häufig als \rCode{DOUBLE} bezeichnet).
    \end{itemize}

    \subsection{Zeichenketten}
    \begin{itemize}
        \item \textbf{\rCode{CHAR(q)}}: speichert immer exakt \texttt{q} Zeichen, gegebenenfalls mit Leerzeichen aufgefüllt.
        \item \textbf{\rCode{VARCHAR(q)}}: speichert bis zu \texttt{q} Zeichen.
    \end{itemize}

    \subsection{Datum und Zeit}
    \begin{itemize}
        \item \textbf{\rCode{DATE}}: repräsentiert ein Datum, Ausgabeformat z.\,B. \rCode{'YYYY-MM-DD'} (ISO 8601).
        \item \textbf{\rCode{TIME}}: repräsentiert eine Uhrzeit im Format \rCode{'HH:MM:SS'} (ISO 8601).
        \item \textbf{\rCode{TIMESTAMP}}: kombiniert Datum und Uhrzeit, z.\,B. \rCode{'YYYY-MM-DD HH:MM:SS'}.
        \begin{itemize}
            \item Die Funktion \rCode{CURRENT\_TIMESTAMP()} liefert den aktuellen Zeitpunkt zurück.
            \item Beispiel: \rCode{INSERT INTO tab VALUES (..., CURRENT\_TIMESTAMP, ...);}
        \end{itemize}
    \end{itemize}

    \subsection{Spezielle Datentypen für umfangreiche Daten}
    \begin{itemize}
        \item \textbf{\rCode{TEXT}}: Speicherung sehr langer Zeichenfolgen (bis zu 1\,GB); 
        im Standard-SQL als \rCode{CLOB} (Character Large Object) bezeichnet.
        \item \textbf{\rCode{BYTEA}}: Speicherung von Binärdaten; 
        im Standard-SQL als \rCode{BLOB} (Binary Large Object) bezeichnet.
    \end{itemize}

    \begin{tcolorbox}[red, title={Hinweis}]
        Die Unterstützung und Einschränkungen dieser Datentypen hängen stark vom jeweiligen DBMS ab. 
        Insbesondere große Text- und Binärfelder (\rCode{TEXT}, \rCode{BYTEA}) sind oft nur eingeschränkt in Abfragen nutzbar.
    \end{tcolorbox}

    \section{Wartości \rCode{NULL} i logika trójwartościowa}

W języku SQL każda kolumna może przyjmować specjalną wartość \rCode{NULL}, 
która nie oznacza zera, pustego tekstu ani wartości fałszywej. 
\rCode{NULL} oznacza po prostu \textit{„brak danych”} lub \textit{„wartość nieznana”}. 
Z tego powodu w SQL stosowana jest nie klasyczna logika dwuwartościowa, 
lecz rozszerzona logika trójwartościowa (\textit{three-valued logic}).

\subsection{Logika dwuwartościowa}

W klasycznej logice występują tylko dwa stany: \textit{prawda (t)} i \textit{fałsz (f)}.

\begin{center}
\begin{tabular}{c|c|c|c|c}
X & Y & \rCode{NOT X} & \rCode{X AND Y} & \rCode{X OR Y} \\
\hline
t & t & f & t & t \\
t & f & f & f & t \\
f & t & t & f & t \\
f & f & t & f & f \\
\end{tabular}
\end{center}

\subsection{Problem wartości \rCode{NULL}}

Dla kolumn, które mogą zawierać \rCode{NULL}, 
porównania takie jak \rCode{=}, \rCode{<>}, \rCode{>}, \rCode{<} nie mogą zostać jednoznacznie rozstrzygnięte.  
Jeżeli jedna z wartości jest \rCode{NULL}, baza danych nie wie, czy warunek jest prawdziwy, czy fałszywy.  
Dlatego wprowadzono trzeci stan logiczny — \textit{nieznany (u)}.

\subsection{Logika trójwartościowa}

W logice trójwartościowej każdy warunek może przyjmować jedną z trzech wartości:
\textbf{prawda (t)}, \textbf{fałsz (f)} lub \textbf{nieznany (u)}.

\begin{center}
\begin{tabular}{c|c|c|c|c}
X & Y & \rCode{NOT X} & \rCode{X AND Y} & \rCode{X OR Y} \\
\hline
t & t & f & t & t \\
t & f & f & f & t \\
t & u & f & u & t \\
f & t & t & f & t \\
f & f & t & f & f \\
f & u & t & f & u \\
u & t & u & u & t \\
u & f & u & f & u \\
u & u & u & u & u \\
\end{tabular}
\end{center}

\subsection{Przykład praktyczny}

\begin{lstlisting}[style=sqlstyle]
SELECT * FROM Mitarbeiter WHERE Gehalt > 2000;
\end{lstlisting}

Jeśli w tabeli \rCode{Mitarbeiter} znajdują się następujące dane:

\begin{center}
\begin{tabular}{l|c}
Name & Gehalt \\
\hline
Anna & 3000 \\
Bob  & NULL \\
Eva  & 1500 \\
\end{tabular}
\end{center}

to wynik zapytania będzie zawierał jedynie rekord \texttt{Anna}, ponieważ:
\begin{itemize}
    \item \textbf{Anna:} 3000 > 2000 → \textit{prawda (t)}
    \item \textbf{Bob:} \rCode{NULL} > 2000 → \textit{nieznany (u)}
    \item \textbf{Eva:} 1500 > 2000 → \textit{fałsz (f)}
\end{itemize}

SQL zwraca tylko te wiersze, dla których warunek jest \textbf{prawdziwy (w)}.  
Wiersze z wynikiem \textit{nieznany (u)} są pomijane, ale nie są traktowane jako fałszywe.

\subsection{Porównania z \rCode{NULL}}

Aby uwzględnić wartości \rCode{NULL} w zapytaniach, należy używać operatorów:
\begin{itemize}
    \item \rCode{IS NULL}
    \item \rCode{IS NOT NULL}
\end{itemize}

\begin{lstlisting}[style=sqlstyle]
SELECT * FROM Mitarbeiter WHERE Gehalt IS NULL;
\end{lstlisting}

Porównania w stylu \rCode{= NULL} lub \rCode{<> NULL} zawsze zwrócą wynik \textit{nieznany (u)}.

\pheading{Podsumowanie}
\begin{itemize}
    \item Klasyczna logika: \textbf{prawda} / \textbf{fałsz}.
    \item Logika SQL: \textbf{prawda} / \textbf{fałsz} / \textbf{nieznany}.
    \item Porównanie z \rCode{NULL} → wynik \textbf{nieznany}.
    \item Aby sprawdzić brak wartości, używaj \rCode{IS NULL} i \rCode{IS NOT NULL}.
\end{itemize}

\section{Ograniczenia integralności danych (\rCode{CONSTRAINTS})\label{sql:constraints}}

    Ograniczenia integralności (\rCode{CONSTRAINTS}) służą do kontrolowania poprawności danych 
    wprowadzanych do tabeli. Dzięki nim można automatycznie wymusić określone reguły, 
    np. minimalne lub maksymalne wartości, unikalność, czy relacje między tabelami.

\subsection{Przykład z warunkiem \rCode{CHECK}}

    Załóżmy, że sprzedawcy o statusie \rCode{Junior} mogą zarabiać maksymalnie 2000.

    \begin{lstlisting}[style=sqlstyle]
        CONSTRAINT GehaltsgrenzeJunior
            CHECK (NOT(Status='Junior') OR Gehalt <= 2000)
    \end{lstlisting}

    Zasada działania:
    \begin{itemize}
        \item Dla wszystkich rekordów, w których \rCode{Status='Junior'}, 
        sprawdzany jest dodatkowy warunek \rCode{Gehalt <= 2000}.
        \item Wiersze, które nie spełniają tego warunku, nie zostaną zaakceptowane przez bazę danych.
        \item Dla pozostałych rekordów (nie-\rCode{Junior}) warunek \rCode{NOT(Status='Junior')} jest prawdziwy, 
        więc całe wyrażenie w \rCode{CHECK} również daje wynik \textit{true}.
    \end{itemize}

    \pheading{Interpretacja logiczna}
    Wyrażenie \rCode{NOT(Status='Junior') OR Gehalt <= 2000} odpowiada zasadzie:
    \textit{„Jeśli pracownik ma status Junior, to jego pensja musi być mniejsza lub równa 2000.”}

\pheading{Przykład: Ograniczenie warunkowe dla wartości płacy}

    Załóżmy, że programiści o statusie \rCode{Junior} mogą zarabiać maksymalnie 2000.  
    Aby to wymusić, można zdefiniować ograniczenie \rCode{CHECK}:

    \begin{lstlisting}[style=sqlstyle]
    CONSTRAINT GehaltsgrenzeJunior
        CHECK (NOT(Status='Junior') OR Gehalt <= 2000)
    \end{lstlisting}

    \pheading{Interpretacja}

    To wyrażenie odpowiada zasadzie logicznej:

    \begin{center}
    \textit{„Jeśli pracownik ma status Junior, to jego pensja musi być mniejsza lub równa 2000.”}
    \end{center}

    W logice formalnej warunek ten można zapisać jako implikację:
    \[
    Status = \textit{'Junior'} \Rightarrow Gehalt \le 2000
    \]
    Ponieważ SQL nie posiada operatora „implikacji” (\rCode{$\Rightarrow$}),  
    stosuje się równoważne logicznie wyrażenie:
    \[
    \text{NOT}(Status=\textit{'Junior'}) \text{ OR } Gehalt \le 2000
    \]

    \pheading{Zasada działania}

    Warunek \rCode{CHECK} musi być prawdziwy (\textit{TRUE}), aby rekord został przyjęty przez bazę danych.  
    Operator \rCode{NOT} odwraca wynik porównania \rCode{Status='Junior'}, a operator \rCode{OR} zwraca wartość \textit{TRUE},  
    jeśli przynajmniej jeden z warunków jest spełniony.

    \begin{center}
    \begin{tabular}{l|c|c|c|c|c}
    \textbf{Status} & \textbf{Gehalt} & \rCode{Status='Junior'} & \rCode{NOT(...)} & \rCode{Gehalt<=2000} & \textbf{Wynik końcowy} \\
    \hline
    Junior & 1800 & t & f & t & \textbf{TRUE} \\
    Junior & 2500 & t & f & f & \textbf{FALSE} \\
    Senior & 2500 & f & t & f & \textbf{TRUE} \\
    Senior & 1500 & f & t & t & \textbf{TRUE} \\
    \end{tabular}
    \end{center}


    \pheading{Wniosek}

    \begin{itemize}
        \item Jeśli pracownik \textbf{nie jest Juniorem}, warunek jest zawsze spełniony.
        \item Jeśli \textbf{jest Juniorem}, musi spełniać \rCode{Gehalt <= 2000}.
        \item W przeciwnym razie baza danych odrzuci wiersz przy próbie wstawienia lub aktualizacji.
    \end{itemize}

\subsection{Dodatkowe ograniczenia integralności w SQL}

    Poza kluczami głównymi (\rCode{PRIMARY KEY}) i obcymi (\rCode{FOREIGN KEY}) w SQL można definiować 
    dodatkowe ograniczenia — tzw. \textit{Constraints}, które zapewniają spójność danych i 
    kontrolują poprawność wartości w tabelach.

\subsubsection{Definiowanie ograniczeń}

    Przykład tabeli ze zdefiniowanymi constraintami:
    \begin{lstlisting}[style=sqlstyle]
    CREATE TABLE Verkaeufer (
        Vnr INTEGER,
        Name VARCHAR(6) NOT NULL,
        Status VARCHAR(7) DEFAULT 'Junior'
            CONSTRAINT StatusHatWert
            CHECK (Status IS NOT NULL),
        Gehalt INTEGER,
        PRIMARY KEY (Vnr),
        CONSTRAINT GehaltImmerAngegeben
            CHECK (Gehalt IS NOT NULL)
    );
    \end{lstlisting}

\pheading{Opis}
    \begin{itemize}
        \item \rCode{NOT NULL} – kolumna nie może zawierać wartości pustych.
        \item \rCode{DEFAULT 'Junior'} – przypisuje domyślną wartość, jeśli nie zostanie podana przy wstawianiu danych.
        \item \rCode{CHECK(...)} – warunek logiczny, który musi być spełniony dla każdego rekordu.
        \item \rCode{CONSTRAINT <nazwa>} – nadaje ograniczeniu nazwę, dzięki czemu pojawia się ona w komunikatach błędów.
    \end{itemize}

\subsubsection{Rodzaje constraintów}
    \begin{itemize}
        \item \textbf{Spalten-Constraint} — dotyczy jednej kolumny (np. \rCode{Name VARCHAR(6) NOT NULL}).
        \item \textbf{Tabellen-Constraint} — odnosi się do całego wiersza tabeli (np. \rCode{CHECK(Gehalt IS NOT NULL)}).
        \item \textbf{UNIQUE} — gwarantuje unikalność wartości w kolumnie lub kombinacji kolumn.
    \end{itemize}

    \begin{lstlisting}[style=sqlstyle]
    -- Przyklady unikalnosci
    Name VARCHAR(6) UNIQUE
    CONSTRAINT EindeutigerName UNIQUE(Name)
    Name VARCHAR(6) NOT NULL UNIQUE
    UNIQUE(X, Y)  -- unikalnosc kombinacji kolumn
    \end{lstlisting}

\pheading{Uwagi praktyczne}
    \begin{itemize}
        \item \rCode{NOT NULL} nie jest wymagane dla kluczy głównych – wynika to z ich definicji.
        \item Jeśli baza danych wykryje, że warunek \rCode{CHECK} zwraca \rCode{FALSE}, operacja (INSERT/UPDATE) zostanie przerwana.
        \item W niektórych DBMS operacja jest przerywana także wtedy, gdy warunek zwróci \rCode{UNKNOWN} (np. z powodu \rCode{NULL}).
        \item Ograniczenia dotyczące wielu kolumn muszą być definiowane jako \textbf{Tabellen-Constraints}.
    \end{itemize}

\section{Änderungen in Tabellenstrukturen}
    \begin{tcolorbox}[red, title={Hinweis}]
        Die Änderungen von Tabellenstrukturen sollen vermieden werden - möglichst nur Ergänzungen für existirende Tabellen oder Hinzufühen neuer Tabellen.
    \end{tcolorbox}

    Die Änderungen können über Befehl \rCode{ALTER} vorgenommen werden

    \begin{lstlisting}[style=sqlstyle]
        ALTER TABLE Verkaeufer ADD Klasse VARCHAR(1);

        ALTER TABLE Verkaeufer ADD
            CONSTRAINT Klassenwerte CHECK (Klasse='A'
            OR Klasse ='B' OR Klasse ='C');
    \end{lstlisting}

    \begin{itemize}
        \item Bei Spaltenergänzung kann ein Default-Wert angegeben werden, sonst wird die Spalte mit NULL-Werten gefüllt.
        \item Löschen von Constraints:  
        \begin{lstlisting}[style=sqlstyle]
            ALTER TABLE <Tabellenname> DROP CONSTRAINT <Constraintname>
        \end{lstlisting}
        \item Constraints können de- und aktiviert werden, um kurzzeitig erforderliche inkonsistente Zustände zu erlauben
    \end{itemize}

